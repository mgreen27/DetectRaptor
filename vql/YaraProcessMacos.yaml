name: Macos.Detection.YaraProcessMacos
author: Matt Green - @mgreen27
description: |
   This artifact is a bulk yara hunt for Macos Process Yara.

   This artifact is automatically generated by DetectRaptor.
   Default yara set extracts all yara-forge yara rules with "memory" string.
   
   Additional detection can be added to the artifact as desired.

   NOTE: MacOS process scanning can throw up several access errors caused by OS
   memory permissions.

reference:
  - https://github.com/mgreen27/DetectRaptor
  - https://github.com/YARAHQ/yara-forge

type: CLIENT
resources:
  timeout: 9000

parameters:
  - name: ProcessRegex
    default: .
    type: regex
  - name: PidRegex
    default: .
    type: regex
  - name: UploadHits
    type: bool
  - name: YaraRule
    type: yara
    description: Final Yara option and the default if no other options provided.
    default: |
        rule BINARYALERT_Hacktool_Macos_Macpmem {
            meta:
        		description = "MacPmem enables read/write access to physical memory on macOS. Can be used by CSIRT teams and attackers."
        		author = "@mimeframe"
        		id = "4890598e-936c-5a4d-9004-88ff4fe57c49"
        		date = "2017-08-11"
        		modified = "2017-08-11"
        		reference = "https://github.com/google/rekall/tree/master/tools/osx/MacPmem"
        		source_url = "https://github.com/airbnb/binaryalert//blob/a9c0f06affc35e1f8e45bb77f835b92350c68a0b/rules/public/hacktool/macos/hacktool_macos_macpmem.yara#L3-L22"
        		license_url = "https://github.com/airbnb/binaryalert//blob/a9c0f06affc35e1f8e45bb77f835b92350c68a0b/LICENSE"
        		logic_hash = "d64b5a5423932211e3b72d949028f3f0ed1f1435e9584cffa947f2bd4846c29b"
        		score = 75
        		quality = 80
        		tags = ""
        
        	strings:
        		$a1 = "%s/MacPmem.kext" wide ascii
        		$a2 = "The Pmem physical memory imager." wide ascii
        		$a3 = "The OSXPmem memory imager." wide ascii
        		$a4 = "These AFF4 Volumes will be loaded and their metadata will be parsed before the program runs." wide ascii
        		$a5 = "Pmem driver version incompatible. Reported" wide ascii
        		$a6 = "Memory access driver left loaded since you specified the -l flag." wide ascii
        		$b1 = "Unloading MacPmem" wide ascii
        		$b2 = "MacPmem load tag is" wide ascii
        
        	condition:
        		BINARYALERT_Macho_PRIVATE and 2 of ( $a* ) or all of ( $b* )
        }

  - name: NumberOfHits
    description: THis artifact will stop by default at one hit. This setting allows additional hits
    default: 1
    type: int
  - name: ContextBytes
    description: Include this amount of bytes around hit as context.
    default: 0
    type: int64
  - name: ExePathWhitelist
    description: Regex of ProcessPaths to exclude
    type: regex

sources:
  - precondition:
      SELECT OS From info() where OS = 'darwin'

    query: |
      -- find velociraptor process
      LET me <= SELECT Pid FROM pslist(pid=getpid())

      -- find all processes and add filters
      LET processes = SELECT
             Name as ProcessName,
             Exe as ProcessPath,
             CommandLine, Pid
        FROM pslist()
        WHERE
            Name =~ ProcessRegex
            AND format(format="%d", args=Pid) =~ PidRegex
            AND NOT Pid in me.Pid
            AND NOT if(condition=ExePathWhitelist,
                    then= Exe=~ExePathWhitelist)
            AND log(message=format(format="Scanning pid %v: %v", args=[
                Pid, CommandLine]))

      -- scan processes in scope with our rule, limit 1 hit
      LET hits = SELECT * FROM foreach(
        row=processes,
        query={
            SELECT
                ProcessName,
                ProcessPath,
                CommandLine,
                Pid,
                Rule,
                Tag,
                Meta,
                String.Name as YaraString,
                String.Offset as HitOffset,
                upload( accessor='scope',
                    file='String.Data',
                    name=format(format="%v-%v_%v_%v",
                    args=[ ProcessName, Pid, String.Offset, ContextBytes ]
                        )) as HitContext
             FROM proc_yara(
                        pid=Pid,
                        rules=YaraRule,
                        context=ContextBytes,
                        number=NumberOfHits,
                        vars=dict(filepath=ProcessPath)
                    )
          })

      -- upload hits using the process accessor
      LET upload_hits = SELECT *,
          upload(
            accessor="process",
            file=format(format="/%v", args=Pid),
            name=pathspec(Path=format(format='%v-%v.dmp',
                          args= [ ProcessName, Pid ]))) as ProcessDump
      FROM hits
      WHERE log(message=format(format='Will upload %v: %v', args=[Pid, ProcessName]))

      -- return rows
      SELECT * FROM if(condition=UploadHits,
        then=upload_hits,
        else=hits)

column_types:
  - name: HitContext
    type: preview_upload
